---
title: "data_vincent"
author: "Rémi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(igraph)
library(ade4)
```

# Informations of the dataset

The R dataset consists of the bipartite plant-pollinator interaction matrices (*bipartite.networks*) for 18 subseas (3 subseasons per 6 years), 18 subseasonal dependence matrices (*directed.networks*), and the plant species (*plant.id*) and pollinator species (*pollinator.id*) identification codes. The code used for the analyses (miele-JAE.R) is also provided.

18 seasons, 59 plants and 196 pollinators

```{r}
season_1 <- bipartite.networks[1, , ]
# View(season_1)
# which(season_1[2,] != 0)# pas beaucoup differents de 0

# to keep only the connected species
season_1_con <- season_1[which(rowSums(season_1) != 0), which(colSums(season_1) != 0)]


plot(graph_from_incidence_matrix(season_1_con), vertex.size=5)
```


```{r}
# pollinator.id
# plant.id
```

# Analysis using the CA

```{r}
obs_netw <- lapply(1:18, function(i) bipartite.networks[i, , , drop = TRUE])
names(obs_netw) <- dimnames(bipartite.networks[[1]])

plot(foucart(lapply(obs_netw, as.data.frame), scannf = F, nf = 2))
```

On dirait que "leip.ino" "lei.cri" "lep.nig" "dia.bar" se démarquent grandement pour ce qui est des colonnes et sph.min et lec.het pour ce qui est des lignes. Ce qui signifie très probablement que ce sont des espèces qui interagissent entre elles ou qui tout au moins ce sont des espèce qui sont non connéctée à la composante géante dans l'un des graphes.

## CA on only the giant component

```{r}
not_always_con <- c()
for (i in 1:18) {
  sampled_netw <- bipartite.networks[i, , ]
  # to keep only the connected species
  sampled_netw_con <- sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
  component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
  if (length(component$csize) != 1) {
    print(paste("The network",i, "is not strongly connected, there is", component$no, "connected components"))
    print(names(component$membership[which(component$membership != 1)]))
    
    print("are/is not part of of the giant component.")
    not_always_con <- c(not_always_con, names(component$membership[which(component$membership != 1)]))
  }
}

print(length(unique(not_always_con)))
print(unique(not_always_con))
```

### Keep only giant component

```{r}
row_to_keep <- setdiff(rownames(bipartite.networks[1, , ]), not_always_con)
# row_to_keep

col_to_keep <- setdiff(colnames(bipartite.networks[1, , ]), not_always_con)
# col_to_keep
```


```{r}
obs_netw <- lapply(1:18, function(i) bipartite.networks[i, row_to_keep, col_to_keep, drop = TRUE])
names(obs_netw) <- dimnames(bipartite.networks[[1]])
plot(foucart(lapply(obs_netw, as.data.frame), scannf = F, nf = 2))
```


## Aggregated for each season

```{r}
season <- c(1, 4, 7, 10, 13, 16)
for (i in 0:2) {
  plot(foucart(lapply(obs_netw, as.data.frame)[season + i], scannf = F, nf = 2))
}
```

## Aggregated for each year

```{r}
for (i in 0:5) {
  plot(foucart(lapply(obs_netw, as.data.frame)[(1+3*i):(3+3*i)], scannf = F, nf = 2))
}
```

# Nombre d'observations

On a un des réseau qui me semblent "creux" et en effet, on environ 10 fois moins d'observations que d'interactions possibles. ce qui implique un biais d'échantillonnage fort

```{r}
nobs <- c()
for (i in 1:18) {
  nobs <- c(nobs, sum(obs_netw[[i]]))
}
mean(nobs)

59*196
```

## Essayer de reconstruire le réseau moyen

```{r}
tab = Reduce('+', obs_netw) # afin de générer le réseau moyen

afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)

par(mfrow=c(2,2))
# table.value(simulated_network$trait$matching_matrix, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # trait matching matrix et tri selon le premier axe
table.value(tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # réseau moyen observé
toto = reconst(afc.tab, nf = 8) # pour reconstruire le réseau moyen à partir des positions sur l'AFC mais on voudrait plustôt obtenir le trait matching
table.value(toto, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # plot le réseau reconstruit
table.value(afc.tab$tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # transformed average table
```

# Visualisation avec bipartite

```{r}
library(bipartite)
```

```{r}
visweb(bipartite.networks[1, , ], box.border = "white")
```

# Observe Data

For each Of the points, I'll do it for only the first network in a first time

## Are interactions between two species random or can we make a link between it and the abundance of each species participating

Meaning that if we use the number of interactions of a specie as a proxy of it's abundance, is there a direct link between these abundances (hence divide by abund spe 1 * abund spe 2 of the abundance in this network)

let's do it only for the interact more than 3 time over the 18 networks (equivalent to having less than 15 networks where it is != 0)

*prendre une position au hasard dans le réseaux et faire des tests*

*attention variance plus importante quand bcp interactions *

```{r}
interaction_frame <- names(which(bipartite.networks[ , "con.mic","bombil11"] != 0))

var_int <- function(spe_1, spe_2){
  int_frame <- names(which(bipartite.networks[ , spe_1, spe_2] != 0)) # get only the frames where there is interaction
  if (length(int_frame) > 3) { # if more than 3 frames
    int_count <- c()
    for (i in int_frame){
      abund_1 <- sum(bipartite.networks[i, spe_1, ]) # abund here is to nb of int of a spe
      abund_2 <- sum(bipartite.networks[i, , spe_2])
      int_count <- c(int_count, bipartite.networks[i, spe_1, spe_2] / (abund_1 * abund_2))
    }
    return(list(mean = mean(int_count), sd = sd(int_count)))
  } 
  else {
    return(list(mean = 0, sd = 0)) # if not enough int observed in the network serie
  }
}

# var_int("con.mic", "bombil11") # un exemple qui fonctionne bien

distrib_int <- list( mean = array(NA, dim = c(59, 196)), sd = array(NA, dim = c(59, 196)))
rownames(distrib_int$mean) <- plant.id
colnames(distrib_int$mean) <- pollinator.id
rownames(distrib_int$sd) <- plant.id
colnames(distrib_int$sd) <- pollinator.id

for (pol in pollinator.id){
  for (pla in plant.id){
    distrib_int$mean[pla, pol] <- var_int(pla, pol)$mean
    distrib_int$sd[pla, pol] <- var_int(pla, pol)$sd
  }
}
# pollinator.id

table.value(distrib_int$sd, grid = F)
table.value(distrib_int$mean, grid = F)

distrib_variation <- array(0, dim = c(59, 196))
rownames(distrib_variation) <- plant.id
colnames(distrib_variation) <- pollinator.id

distrib_variation[distrib_int$sd != 0 & distrib_int$mean != 0] <- distrib_int$sd[distrib_int$sd != 0 & distrib_int$mean != 0] / distrib_int$mean[distrib_int$sd != 0 & distrib_int$mean != 0]

table.value(distrib_variation)
# distrib_int$sd != 0 & distrib_int$mean != 0
```

```{r}
hist(log(distrib_variation[which(distrib_variation != 0)]))
boxplot(as.vector(distrib_variation[which(distrib_variation != 0)]))
hist(as.vector(distrib_variation[which(distrib_variation != 0)]))
```

## Are interaction proportion stable relativly to the abundances?

Here, I wanna see if it's possible to check if the proportions of interactions relatively to the abundances is something stable or not. In this case, the abundances would be the relative abundance (frequency of observation) over the total frequency of this "part" of the graph (plant or pol). Hence I would generate for each specie a matrix with in column this value across the species and in col across the list of networks.

make a first table which is the cross abundance, = proba of meeting randomly (neutral effect)

By normalizing by the neutral effect, we also get rid of when the species are not observed as we would obtain NaN due to the division by 0.

### Neutral effect

```{r}
neutral_effect <- sapply(1:18, function(i) outer(rowSums(bipartite.networks[i,,]), colSums(bipartite.networks[1,,])), simplify = "array") #nearly the same as making a matrix product between the two sum vectors but here with the array format I keep the names

neutral_effect <- aperm(neutral_effect, c(3,1,2)) # by using Sapply, the time dimensionwas moved as the 3rd one
dimnames(neutral_effect)[1] <- dimnames(bipartite.networks)[1] # to have the time names
```

### "Non-neutral" effect

Here, when we have x/y, if x = 0 -> 0, if x!=0 and y = 0 -> inf
but it means that there is no interaction for each species and that there is on observe beteen the two of them: NONSENSE

```{r}
trait_effect <- sapply(1:18, function(i) bipartite.networks[i, , ] / neutral_effect[i,,], simplify = "array") # divide the observed by the neutral effect. Hence when there is a neutral effect of 0, we will have a trait effect associated of NaN as we can not divide by 0

trait_effect <- aperm(trait_effect, c(3, 1, 2))
dimnames(trait_effect)[1] <- dimnames(bipartite.networks)[1]

# 0.1/0
# 0/0

# trait_effect[1, , ] > 0 # semble enfin marcher
```

### Look at the variation of this non neutral effect


```{r}
var_trait <- function(spe_1, spe_2){
  int_frame <- names(which(neutral_effect[,spe_1, spe_2] > 0))
  if (length(int_frame) >= 3){
    pot_int <- trait_effect[int_frame, spe_1, spe_2]
    return(list(mean = mean(pot_int), sd = sd(pot_int)))
  }
  else {
    return(list(mean = 0, sd = 0))
  }
}

# names(which(neutral_effect[,"con.mic", "bombil11"] > 0))
# (int_frame <- names(which(neutral_effect[,"con.mic", "bombil11"] > 0)))
# trait_effect[int_frame,"con.mic", "bombil11"]
# mean(trait_effect[int_frame,"con.mic", "bombil11"])
# sd(trait_effect[int_frame,"con.mic", "bombil11"])

# names(which(trait_effect[,"con.mic", "bombil11"] > 0))
# names(which(bipartite.networks[ ,"con.mic", "bombil11"] != 0)) # on obtient bien le même resultat que la ligne précédente...enfin


distrib_trait <- list( mean = array(NA, dim = c(59, 196)), sd = array(NA, dim = c(59, 196)))
rownames(distrib_trait$mean) <- plant.id
colnames(distrib_trait$mean) <- pollinator.id
rownames(distrib_trait$sd) <- plant.id
colnames(distrib_trait$sd) <- pollinator.id


for (pol in pollinator.id){
  for (pla in plant.id){
    distrib_trait$mean[pla, pol] <- var_trait(pla, pol)$mean
    distrib_trait$sd[pla, pol] <- var_trait(pla, pol)$sd
  }
}

hist(as.vector(distrib_trait$sd/distrib_trait$mean)) # as NaN are not displayed (when 0/0), we do not have to worry about the 0
hist(as.vector(distrib_trait$mean)[which(as.vector(distrib_trait$mean) != 0)])
hist(as.vector(distrib_trait$sd)[which(as.vector(distrib_trait$sd) != 0)])
```




# Todo


puis regarder si le rôle change

regarder si les abondances des autres personnes avec laquel il interagit varie: regarder le turnover des abondances

regarder ce qui change 

