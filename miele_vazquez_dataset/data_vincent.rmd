---
title: "data_vincent"
author: "Rémi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(igraph)
library(ade4)
```

# Informations of the dataset

The R dataset consists of the bipartite plant-pollinator interaction matrices (*bipartite.networks*) for 18 subseas (3 subseasons per 6 years), 18 subseasonal dependence matrices (*directed.networks*), and the plant species (*plant.id*) and pollinator species (*pollinator.id*) identification codes. The code used for the analyses (miele-JAE.R) is also provided.

18 seasons, 59 plants and 196 pollinators

```{r}
season_1 <- bipartite.networks[1, , ]
# View(season_1)
# which(season_1[2,] != 0)# pas beaucoup differents de 0

# to keep only the connected species
season_1_con <- season_1[which(rowSums(season_1) != 0), which(colSums(season_1) != 0)]


plot(graph_from_incidence_matrix(season_1_con), vertex.size=5)
```


```{r}
# pollinator.id
# plant.id
```

# Analysis using the CA

```{r}
obs_netw <- lapply(1:18, function(i) bipartite.networks[i, , , drop = TRUE])
names(obs_netw) <- dimnames(bipartite.networks[[1]])

plot(foucart(lapply(obs_netw, as.data.frame), scannf = F, nf = 2))
```

On dirait que "leip.ino" "lei.cri" "lep.nig" "dia.bar" se démarquent grandement pour ce qui est des colonnes et sph.min et lec.het pour ce qui est des lignes. Ce qui signifie très probablement que ce sont des espèces qui interagissent entre elles ou qui tout au moins ce sont des espèce qui sont non connéctée à la composante géante dans l'un des graphes.

## CA on only the giant component

```{r}
not_always_con <- c()
for (i in 1:18) {
  sampled_netw <- bipartite.networks[i, , ]
  # to keep only the connected species
  sampled_netw_con <- sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
  component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
  if (length(component$csize) != 1) {
    print(paste("The network",i, "is not strongly connected, there is", component$no, "connected components"))
    print(names(component$membership[which(component$membership != 1)]))
    
    print("are/is not part of of the giant component.")
    not_always_con <- c(not_always_con, names(component$membership[which(component$membership != 1)]))
  }
}

print(length(unique(not_always_con)))
print(unique(not_always_con))
```

### Keep only giant component

```{r}
row_to_keep <- setdiff(rownames(bipartite.networks[1, , ]), not_always_con)
# row_to_keep

col_to_keep <- setdiff(colnames(bipartite.networks[1, , ]), not_always_con)
# col_to_keep
```


```{r}
obs_netw <- lapply(1:18, function(i) bipartite.networks[i, row_to_keep, col_to_keep, drop = TRUE])
names(obs_netw) <- dimnames(bipartite.networks[[1]])
plot(foucart(lapply(obs_netw, as.data.frame), scannf = F, nf = 2))
```


## Aggregated for each season

```{r}
season <- c(1, 4, 7, 10, 13, 16)
for (i in 0:2) {
  plot(foucart(lapply(obs_netw, as.data.frame)[season + i], scannf = F, nf = 2))
}
```

## Aggregated for each year

```{r}
for (i in 0:5) {
  plot(foucart(lapply(obs_netw, as.data.frame)[(1+3*i):(3+3*i)], scannf = F, nf = 2))
}
```

# Nombre d'observations

On a un des réseau qui me semblent "creux" et en effet, on environ 10 fois moins d'observations que d'interactions possibles. ce qui implique un biais d'échantillonnage fort

```{r}
nobs <- c()
for (i in 1:18) {
  nobs <- c(nobs, sum(obs_netw[[i]]))
}
mean(nobs)

59*196
```

## Essayer de reconstruire le réseau moyen

```{r}
tab = Reduce('+', obs_netw) # afin de générer le réseau moyen

afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)

par(mfrow=c(2,2))
# table.value(simulated_network$trait$matching_matrix, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # trait matching matrix et tri selon le premier axe
table.value(tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # réseau moyen observé
toto = reconst(afc.tab, nf = 8) # pour reconstruire le réseau moyen à partir des positions sur l'AFC mais on voudrait plustôt obtenir le trait matching
table.value(toto, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # plot le réseau reconstruit
table.value(afc.tab$tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # transformed average table
```

# Visualisation avec bipartite

```{r}
library(bipartite)
```

```{r}
visweb(bipartite.networks[1, , ],  box.border = "white")
```

