---
title: "Interaction Network"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    highlight: kate
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```

```{r include=FALSE}
library(igraph)
library(tidyverse)
```


# Import file

```{r}
phenology_flower <-read.csv("./data/caradonna_rmbl_flowering_phenology_data_EDI.csv",header=T,sep=",",quot='"')
summary(phenology_flower)
```

check the format

```{r}
if (class(phenology_flower$year)=="factor") phenology_flower$year <-as.numeric(levels(phenology_flower$year))[as.integer(phenology_flower$year) ]               
if (class(phenology_flower$year)=="character") phenology_flower$year <-as.numeric(phenology_flower$year)
if (class(phenology_flower$site)!="factor") phenology_flower$site<- as.factor(phenology_flower$site)
if (class(phenology_flower$plant)!="factor") phenology_flower$plant<- as.factor(phenology_flower$plant)
if (class(phenology_flower$transect)!="factor") phenology_flower$transect<- as.factor(phenology_flower$transect)
if (class(phenology_flower$week_num)=="factor") phenology_flower$week_num <-as.numeric(levels(phenology_flower$week_num))[as.integer(phenology_flower$week_num) ]               
if (class(phenology_flower$week_num)=="character") phenology_flower$week_num <-as.numeric(phenology_flower$week_num)
if (class(phenology_flower$flower_count)=="factor") phenology_flower$flower_count <-as.numeric(levels(phenology_flower$flower_count))[as.integer(phenology_flower$flower_count) ]               
if (class(phenology_flower$flower_count)=="character") phenology_flower$flower_count <-as.numeric(phenology_flower$flower_count)

summary(phenology_flower)
```

# Import data interaction network

```{r}
interaction_netw <-read.csv("./data/caradonna_rmbl_interaction_networks_data_EDI.csv",header=T,sep=",",quot='"')
summary(interaction_netw)
```

Set the columns to the right format.

```{r}                
if (class(interaction_netw$year)=="factor") interaction_netw$year <-as.numeric(levels(interaction_netw$year))[as.integer(interaction_netw$year) ]               
if (class(interaction_netw$year)=="character") interaction_netw$year <-as.numeric(interaction_netw$year)
summary(interaction_netw)
```

# Work on a smaller subset

```{r}
# define a subset
sub_set = interaction_netw[phenology_flower$year == 2013 & interaction_netw$week_num == 2 & phenology_flower$transect == 1, c("pollinator", "plant")]

# Ajouter un filtre pour retirer les interaction en double.
sub_set <- distinct(sub_set)

# Make a dataframe of one column that contain an alternation of source and target vertices
edges_list = sub_set %>% transmute( merged = paste0(pollinator, ",", plant)) %>% separate_rows(merged, sep = ",")

# create a first dataframe in which there will be the nature of each vertex
vert <- rbind(data.frame(name = unique(sub_set$pollinator), cat = "pol"), data.frame(name = unique(sub_set$plant), cat = "pla"))
g <- graph_from_data_frame(sub_set, directed = T, vertices = vert)

vertex_col <- get.vertex.attribute(g, "cat")
colors = c("Green", "Yellow")
vertex_col[vertex_col == "pla"] = colors[1]
vertex_col[vertex_col == "pol"] = colors[2]

# add a type col to visualize the data
V(g)$type = bipartite_mapping(g)$type

plot(g, layout = layout_as_bipartite, vertex.color = vertex_col, edge.arrow.size = .4, vertex.label = NA)
```

# Do the same but for a different time frame

```{r warning=FALSE}
par(mfrow = c(2,3))
for (date_sample in sort(unique(interaction_netw$week_num))[1:6]) {
  # subset
  sub_set = interaction_netw[phenology_flower$year == 2013 & interaction_netw$week_num == date_sample & phenology_flower$transect == 1, c("pollinator", "plant")]
  # remove duplactes
  sub_set <- distinct(sub_set)
  # format the network
  edges_list = sub_set %>% transmute( merged = paste0(pollinator, ",", plant)) %>% separate_rows(merged, sep = ",")
  vert <- rbind(data.frame(name = unique(sub_set$pollinator), cat = "pol"), data.frame(name = unique(sub_set$plant), cat = "pla"))
  g <- graph_from_data_frame(sub_set, directed = T, vertices = vert)
  vertex_col <- get.vertex.attribute(g, "cat")
  colors = c("Green", "Yellow")
  vertex_col[vertex_col == "pla"] = colors[1]
  vertex_col[vertex_col == "pol"] = colors[2]
  V(g)$type = bipartite_mapping(g)$type
  plot(g, layout = layout_as_bipartite, vertex.color = vertex_col, edge.arrow.size = .4, vertex.label = NA, main = date_sample)
}

```

**Could be nice to have the vertices fixed so that we can have only the interactions moving and then, why not make a tiny animation out of it if it works (this way, we won't have many small graphs and it will be easier to see the modifications).**

# ggNetwork

```{r}
interaction_netw <-read.csv("./data/caradonna_rmbl_interaction_networks_data_EDI.csv",header=T,sep=",",quot='"')
summary(interaction_netw)
```


```{r}
library(ggnetwork)
library(ggplot2)
library(dplyr)
library(tidyr)

sub_set <- function(data, year, week, site){
  return(distinct(
    interaction_netw[data$year == year & data$week_num == week & data$site == site, c("pollinator", "plant")]
  ))
}

data1 <- sub_set(interaction_netw, 2013, 2, "shady_point")
```

## vertices

```{r}

# Make a dataframe of one column that contains an alternation of source and target vertices
edge_list <- function(data){
  return(
    data %>%
    transmute(name = paste0(pollinator, ",", plant)) %>%
    separate_rows(name, sep = ",")
  )
}

edge1 <- edge_list(data1)

# Create a first dataframe in which there will be the nature of each vertex
vert_list <- function(data){
  rbind(data.frame(name = unique(data$pollinator), cat = "pol"), 
        data.frame(name = unique(data$plant), cat = "pla"))
}

vert1 <- vert_list(interaction_netw) ################################### N'a pas à être calculé plusieurs fois ##################################

# Create a directed graph

g <- graph_from_data_frame(data1, directed = TRUE, vertices = vert1)

# Set layout positions manually

bipartite_layout_vert <- function(graph){
  vert_pos <- data.frame(
    name = V(graph)$name,
    x = 0, ###################### pas opti ##############################
    y = ifelse(V(graph)$cat == "pol", 0, 1)
  )
  vert_pos[vert_pos$y == 0, "x"] = seq(0,1, by = 1/(length(vert_pos[vert_pos$y == 0, "x"])-1))
  vert_pos[vert_pos$y != 0, "x"] = seq(0,1, by = 1/(length(vert_pos[vert_pos$y != 0, "x"])-1))
  return(vert_pos)
}

vert_pos = bipartite_layout_vert(g) ################################### N'a pas à être calculé plusieurs fois ##################################
```

## edges

```{r}

bipartite_layout_edge <- function(edge_list,vertices_position){
  # associate the position of the staring and ending vertices to the list of edges
  edge = left_join(edge_list,vertices_position, by = "name")
  # separate into a table where there is x_start, y_start, x_end, y_end for each edge
  start_position = edge[seq(1, nrow(edge), by = 2), 2:3]
  colnames(start_position)[1:2] = c("x_start", "y_start")
  end_position = edge[seq(2, nrow(edge), by = 2), 2:3]
  colnames(end_position)[1:2] = c("x_end", "y_end")
  
  edge_position = cbind(start_position,end_position)
  
  # make the arrow of the edge end a bit before the target node
  edge_position$x_dist = edge_position$x_end - edge_position$x_start
  edge_position$y_dist = edge_position$y_end - edge_position$y_start
  edge_position[5:6] = edge_position[5:6] * 0.98
  edge_position$x_end = edge_position$x_start + edge_position$x_dist
  edge_position$y_end = edge_position$y_start + edge_position$y_dist
  
  # return
  return(edge_position)
}

edge_pos <- bipartite_layout_edge(edge1,vert_pos)

```

## plot

```{r}
# Plot the graph
ggplot() +
  geom_edges(data = edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
  geom_nodes(data = vert_pos, aes(x = x, y = y, color = vert1$cat), size = 3) +
  scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
  theme_void() +
  theme(legend.position = "none") +
  coord_fixed()
```


```{r}
for (date in c(1:10)) {
  data1 <- sub_set(interaction_netw, 2013, date, "twin_meadows")
  edge1 <- edge_list(data1)
  vert1 <- vert_list(interaction_netw) ################################### N'a pas à être calculé plusieurs fois ##################################
  g <- graph_from_data_frame(data1, directed = TRUE, vertices = vert1)
  vert_pos = bipartite_layout_vert(g) ################################### N'a pas à être calculé plusieurs fois ##################################
  edge_pos <- bipartite_layout_edge(edge1,vert_pos)
  
  
  figure <- ggplot() +
    geom_edges(data = edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
    geom_nodes(data = vert_pos, aes(x = x, y = y, color = vert1$cat), size = 3) +
    scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
    theme_void() +
    theme(legend.position = "none") +
    coord_fixed()
  
  png(paste0("twin_meadows/plot",date,".png"))
  print(figure)
  dev.off()
}
```

# Todo list:

make an animation and save it
optimize the code to only compute stuff once when possible
put everything into a big function where so that the memory won't fill up needlessly