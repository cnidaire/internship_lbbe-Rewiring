---
title: "Interaction Network"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    highlight: kate
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```

```{r include=FALSE}
library(igraph)
library(tidyverse)
library(ggnetwork)
library(ggplot2)
library(dplyr)
library(tidyr)
```
# About the data

The data is coming from the article of Caradonna ("interaction rewiring and the rapid turnover of plant pollinator networks"). The data is coming from weekly census across 3 years in a sub-alpine ecosystem. The main goal of this census was to quantify the within season turnover of the interactions between plant pollinators.

The study area is snow covered much of the year with a short summer growing season of 3-5 months. Hence the data is observed across the flowering season on weekly intervals (2013: 11 weeks / 2014: 15 weeks / 2015: 16 weeks).

# Import data interaction network

```{r}
interaction_netw <-read.csv("./data/caradonna_rmbl_interaction_networks_data_EDI.csv",header=T,sep=",",quot='"')
summary(interaction_netw)
```

## Set the columns to the right format.

```{r}                
if (class(interaction_netw$year)=="factor") interaction_netw$year <-as.numeric(levels(interaction_netw$year))[as.integer(interaction_netw$year) ]               
if (class(interaction_netw$year)=="character") interaction_netw$year <-as.numeric(interaction_netw$year)
summary(interaction_netw)
```

# Define functions

```{r}
sub_set <- function(data, year, week, site){
  return(distinct(
    data[data$year %in% year & data$week_num %in% week & data$site %in% site, c("pollinator", "plant")]
  ))
}

data1 <- sub_set(interaction_netw, 2013, 2, "shady_point")
```

## Vertices and layout

```{r}

# Make a dataframe of one column that contains an alternation of source and target vertices
edge_list <- function(data){
  return(
    data %>%
    transmute(name = paste0(pollinator, ",", plant)) %>%
    separate_rows(name, sep = ",")
  )
}

edge1 <- edge_list(data1)

# Create a first dataframe in which there will be the nature of each vertex
vert_list <- function(data){
  rbind(data.frame(name = unique(data$pollinator), cat = "pol"), 
        data.frame(name = unique(data$plant), cat = "pla"))
}

vert1 <- vert_list(interaction_netw)

# Create a directed graph

g <- graph_from_data_frame(data1, directed = TRUE, vertices = vert1)

# Set layout positions manually

bipartite_layout_vert <- function(graph){
  vert_pos <- data.frame(
    name = V(graph)$name,
    x = 0,
    y = ifelse(V(graph)$cat == "pol", 0, 1)
  )
  vert_pos[vert_pos$y == 0, "x"] = seq(0,1, by = 1/(length(vert_pos[vert_pos$y == 0, "x"])-1))
  vert_pos[vert_pos$y != 0, "x"] = seq(0,1, by = 1/(length(vert_pos[vert_pos$y != 0, "x"])-1))
  return(vert_pos)
}

vert_pos = bipartite_layout_vert(g)
```

## Edges

```{r}

bipartite_layout_edge <- function(edge_list,vertices_position){
  # associate the position of the staring and ending vertices to the list of edges
  edge = left_join(edge_list,vertices_position, by = "name")
  # separate into a table where there is x_start, y_start, x_end, y_end for each edge
  start_position = edge[seq(1, nrow(edge), by = 2), 2:3]
  colnames(start_position)[1:2] = c("x_start", "y_start")
  end_position = edge[seq(2, nrow(edge), by = 2), 2:3]
  colnames(end_position)[1:2] = c("x_end", "y_end")
  
  edge_position = cbind(start_position,end_position)
  
  # make the arrow of the edge end a bit before the target node
  edge_position$x_dist = edge_position$x_end - edge_position$x_start
  edge_position$y_dist = edge_position$y_end - edge_position$y_start
  edge_position[5:6] = edge_position[5:6] * 0.98
  edge_position$x_end = edge_position$x_start + edge_position$x_dist
  edge_position$y_end = edge_position$y_start + edge_position$y_dist
  
  # return
  return(edge_position)
}

edge_pos <- bipartite_layout_edge(edge1,vert_pos)

```

## Plot

```{r}
# Plot the graph
ggplot() +
  geom_edges(data = edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
  geom_nodes(data = vert_pos, aes(x = x, y = y, color = vert1$cat), size = 3) +
  scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
  theme_void() +
  theme(legend.position = "none") +
  coord_fixed()
```

## Make a big function to save memory

```{r}
master_function <- function(data_file, year, week, site){
  data <- sub_set(data_file, year, week, site)
  edge <- edge_list(data)
  vert <- vert_list(data_file)
  g <- graph_from_data_frame(data, directed = TRUE, vertices = vert)
  vert_pos = bipartite_layout_vert(g)
  edge_pos <- bipartite_layout_edge(edge,vert_pos)
  
  
  figure <- ggplot() +
    geom_edges(data = edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
    geom_nodes(data = vert_pos, aes(x = x, y = y, color = vert$cat), size = 3) +
    scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
    theme_void() +
    theme(legend.position = "none") +
    coord_fixed()
  return(figure)
}
```


```{r}
master_function(interaction_netw, 2013, 2, "shady_point")
```
That's way more convenient.

# Data visualization and saving of data

```{r}
for (date in c(1:10)) {
  data1 <- sub_set(interaction_netw, 2013, date, "twin_meadows")
  edge1 <- edge_list(data1)
  vert1 <- vert_list(interaction_netw) ################################### N'a pas à être calculé plusieurs fois ##################################
  g <- graph_from_data_frame(data1, directed = TRUE, vertices = vert1)
  vert_pos = bipartite_layout_vert(g) ################################### N'a pas à être calculé plusieurs fois ##################################
  edge_pos <- bipartite_layout_edge(edge1,vert_pos)
  
  
  figure <- ggplot() +
    geom_edges(data = edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
    geom_nodes(data = vert_pos, aes(x = x, y = y, color = vert1$cat), size = 3) +
    scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
    theme_void() +
    theme(legend.position = "none") +
    coord_fixed()
  
  png(paste0("twin_meadows/plot",date,".png"))
  print(figure)
  dev.off()
}
```


# AFC of the full network

```{r}
full_network <- sub_set(interaction_netw, c(2013:2015), c(1:15), c("shady_point", "twin_meadows"))
full_edge <- edge_list(full_network)
full_vert <- vert_list(interaction_netw)
full_graph <- graph_from_data_frame(full_network, directed = T, vertices = full_vert)
full_vert_pos <- bipartite_layout_vert(full_graph)
full_edge_pos <- bipartite_layout_edge(full_edge, full_vert_pos)

ggplot() +
geom_edges(data = full_edge_pos, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), arrow = arrow(length = unit(0.2, "cm")), color = "black") +
geom_nodes(data = full_vert_pos, aes(x = x, y = y, color = vert1$cat), size = 3) +
scale_color_manual(values = c("pol" = "#EECE00", "pla" = "#06CB21")) +
theme_void() +
theme(legend.position = "none") +
coord_fixed()
```
Unreadable, of course but it was just to check that it works. 

# Todo list:

- [ ] &nbsp; make an animation and save it
- [ ] &nbsp; optimize the code to only compute stuff once when possible
- [ ] &nbsp; put everything into a big function where so that the memory won't fill up needlessly

- [ ] &nbsp; pull up in similar factors (like one every year) or by site.

- [ ] &nbsp; c'est un eu crade, j'utilise graph_from_data_frame de igraph alors que pour tout le reste, je n'utilise que ggnetwork voir si il n'y a pas un équilivalent chez ggnetwork