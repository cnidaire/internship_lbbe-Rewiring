---
title: "reconstruct_trait_simu"
author: "Rémi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(NetworkEnvGradGeneration)
library(ade4)
library(igraph)
```


```{r}
##################################################"
## reconst.coa reconstitue le tableau original Nij
## ici on reconstitue les ecarts entre pij observé et théorique pi.p.j
## (pij - pi.p.j) pour reconst_afc ou normés par le chi2 ((pij - pi.p.j)/pi.p.j)) pour reconst_afc2
##################################################"

library(ade4)

reconst_afc <- function (dudi, nf = 1, ...) 
{
    ## reconst (pij - pi.p.j)/pi.p.j
    if (!inherits(dudi, "dudi")) 
        stop("Object of class 'dudi' expected")
    if (nf > dudi$nf) 
        stop(paste(nf, "factors need >", dudi$nf, "factors available\n"))
    if (!inherits(dudi, "coa")) 
        stop("Object of class 'dudi' expected")
    pl <- dudi$lw
    pc <- dudi$cw
    n <- dudi$N
    #res0 <- outer(pl, pc) * n
    res0 <- matrix(1, length(pl), length(pc)) # c'est bien pc?
    res <- data.frame(res0-1) # pourquoi pas direct matr(0, pl,pc)?
    names(res) <- names(dudi$tab) # col.names?
    row.names(res) <- row.names(dudi$tab)
    #res0 <- outer(pl, pc) * n
    if (nf == 0) 
        return(res)
    for (i in 1:nf) {
        xli <- dudi$li[, i]
        yc1 <- dudi$c1[, i] # pourquoi li et C1 et pas l1/c1, ou li/co? 
        res <- res + outer(xli, yc1) * res0
    }
    return(res)
} 


reconst_afc2 <- function (dudi, nf = 1, ...) 
{
    ## reconst (pij - pi.p.j)
    if (!inherits(dudi, "dudi")) 
        stop("Object of class 'dudi' expected")
    if (nf > dudi$nf) 
        stop(paste(nf, "factors need >", dudi$nf, "factors available\n"))
    if (!inherits(dudi, "coa")) 
        stop("Object of class 'dudi' expected")
    pl <- dudi$lw
    pc <- dudi$cw
    n <- dudi$N
    res0 <- outer(pl, pc) * n
    res <- data.frame(res0 - 1)
    names(res) <- names(dudi$tab)
    row.names(res) <- row.names(dudi$tab)
    if (nf == 0) 
        return(res)
    for (i in 1:nf) {
        xli <- dudi$li[, i]
        yc1 <- dudi$c1[, i]
        res <- res + outer(xli, yc1) * res0
    }
    return(res)
}
```

# Generate Network

```{r}
simulated_network <- env_grad_netw(nb_resource = 40 , nb_consumer = 60,
                                   nb_location = 16,
                                   know_env_grad_pos = F, ninter = 240, 
                                   mean_tol = 0.2, sd_tol = 0.2,
                                   mean_tol_env = 0.2, sd_tol_env = 0.3,
                                   delta = 1, corr_env_trait = 0)

```


## Extract the giant component

### Extract the components that are not always part of the giant component

```{r}
not_always_con <- c()
for (i in 1:nb_frame) {
  sampled_netw <- simulated_network$obs_network[[i]]
  # to keep only the connected species
  sampled_netw_con <- sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
  component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
  if (length(component$csize) != 1) {
    # print(paste("The network",i, "is not strongly connected, there is", component$no, "connected components"))
    # print(names(component$membership[which(component$membership != which.max(component$csize))]))
    # print("are not part of of the giant component.")
    not_always_con <- c(not_always_con, names(component$membership[which(component$membership != which.max(component$csize))]))
  }
}

print(length(unique(not_always_con)))
print(unique(not_always_con))
length(unique(not_always_con))/(spe_consum + spe_resource) * 100
```

```{r}
filter_giant_component <- function(simu_netw){
  # On observed data
  simu_netw$obs_giant_compo <- lapply(simu_netw$obs_network, function(arr){
    arr[!dimnames(arr)[[1]] %in% unique(not_always_con),
        !dimnames(arr)[[2]] %in% unique(not_always_con)]
  })
  
  # On the trait matching matrix
  simu_netw$trait$giant_compo <- simu_netw$trait$matching_matrix[!dimnames(simu_netw$obs_network[[1]])[[1]] %in% unique(not_always_con),
                                                                                !dimnames(simu_netw$obs_network[[1]])[[2]] %in% unique(not_always_con)]
  
  # On the resource traits
  simu_netw$trait$resource_giant_compo <- simu_netw$trait$trait_resource[!dimnames(simu_netw$trait$trait_resource)[[1]] %in% unique(not_always_con),]
  
  #On the consumer traits
  simu_netw$trait$consumer_giant_compo <- simu_netw$trait$trait_consumer[!dimnames(simu_netw$trait$trait_consumer)[[1]] %in% unique(not_always_con),,] 
}

filter_giant_component(simulated_network)


```


```{r}
ade4::table.value(simulated_network$obs_giant_compo[[1]])
```

```{r}
sampled_netw <- Reduce('+', simulated_network$obs_giant_compo)
# to keep only the connected species
sampled_netw_con <- sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
if (length(component$csize) != 1) {
  print(paste("The network",i, "is not strongly connected, there is", component$no, "connected components"))
  print(names(component$membership[which(component$membership != which.max(component$csize))]))
  print("are not part of of the giant component.")
  not_always_con <- c(not_always_con, names(component$membership[which(component$membership != which.max(component$csize))]))
}
table.value(sampled_netw)

plot(graph_from_incidence_matrix(sampled_netw), vertex.size=5)
```

```{r}
degree(graph_from_incidence_matrix(sampled_netw))
```


```{r}
tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen

afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)

par(mfrow=c(2,2))
ade4::table.value(simulated_network$trait$giant_compo, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1]), csize = 0.8) # trait matching matrix et tri selon le premier axe
ade4::table.value(tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # réseau moyen observé
toto = reconst_afc(afc.tab, nf = 8) # pour reconstruire le réseau moyen à partir des positions sur l'AFC mais on voudrait plustôt obtenir le trait matching
ade4::table.value(toto, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1]), csize = 0.8) # plot le réseau reconstruit
ade4::table.value(afc.tab$tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # transformed average table
```



```{r}
# afc.tab$li

cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
```

```{r}
scatter(afc.tab)
```


```{r}
library(adegraphics)
adegraphics::table.value(afc.tab$tab, coordsx = rank(afc.tab$co[,1]), coordsy  = rank(afc.tab$li[,1]), method = "color", ppoint.cex = 0.2) # transformed average table

image(simulated_network$trait$matching_matrix [order(afc.tab$li[,1]), order(afc.tab$co[,1])])

```

