---
title: "reconstruct_trait_simu"
author: "Rémi"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    highlight: kate
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
```

```{r}
library(NetworkEnvGradGeneration)
library(ade4)
library(igraph)
library(ggplot2)
```
# Reconstruct trait matching

```{r}
##################################################"
## reconst.coa reconstitue le tableau original Nij
## ici on reconstitue les ecarts entre pij observé et théorique pi.p.j
## (pij - pi.p.j) pour reconst_afc ou normés par le chi2 ((pij - pi.p.j)/pi.p.j)) pour reconst_afc2
##################################################"

library(ade4)

reconst_afc <- function (dudi, nf = 1, ...) 
{
    ## reconst (pij - pi.p.j)/pi.p.j
    if (!inherits(dudi, "dudi")) 
        stop("Object of class 'dudi' expected")
    if (nf > dudi$nf) 
        stop(paste(nf, "factors need >", dudi$nf, "factors available\n"))
    if (!inherits(dudi, "coa")) 
        stop("Object of class 'dudi' expected")
    pl <- dudi$lw
    pc <- dudi$cw
    n <- dudi$N
    #res0 <- outer(pl, pc) * n
    res0 <- matrix(1, length(pl), length(pc)) # c'est bien pc?
    res <- data.frame(res0-1) # pourquoi pas direct matr(0, pl,pc)?
    names(res) <- names(dudi$tab) # col.names?
    row.names(res) <- row.names(dudi$tab)
    #res0 <- outer(pl, pc) * n
    if (nf == 0) 
        return(res)
    for (i in 1:nf) {
        xli <- dudi$li[, i]
        yc1 <- dudi$c1[, i] # pourquoi li et C1 et pas l1/c1, ou li/co? 
        res <- res + outer(xli, yc1) * res0
    }
    return(res)
} 


reconst_afc2 <- function (dudi, nf = 1, ...) 
{
    ## reconst (pij - pi.p.j)
    if (!inherits(dudi, "dudi")) 
        stop("Object of class 'dudi' expected")
    if (nf > dudi$nf) 
        stop(paste(nf, "factors need >", dudi$nf, "factors available\n"))
    if (!inherits(dudi, "coa")) 
        stop("Object of class 'dudi' expected")
    pl <- dudi$lw
    pc <- dudi$cw
    n <- dudi$N
    res0 <- outer(pl, pc) * n
    res <- data.frame(res0 - 1)
    names(res) <- names(dudi$tab)
    row.names(res) <- row.names(dudi$tab)
    if (nf == 0) 
        return(res)
    for (i in 1:nf) {
        xli <- dudi$li[, i]
        yc1 <- dudi$c1[, i]
        res <- res + outer(xli, yc1) * res0
    }
    return(res)
}
```

# Generate Network

```{r}
nb_frame = 16
spe_resource = 70
spe_consumer = 190
simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                   nb_location = nb_frame,
                                   know_env_grad_pos = F, ninter = 2400, 
                                   mean_tol = 0.2, sd_tol = 0.2,
                                   mean_tol_env = 100, sd_tol_env = 0.3,
                                   delta = 1, corr_env_trait = 0)

```


## Extract the giant component

### Extract the components that are not always part of the giant component

```{r}
connected_compo <- function(simu_netw, nb_frame){
  not_always_con <- c()
  sampled_netw <- Reduce('+', simulated_network$obs_network)
  sampled_netw_con = sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
  component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
  if (length(component$csize) != 1) {
      not_always_con <- c(not_always_con, names(component$membership[which(component$membership != which.max(component$csize))]))
  }
  
  # print(paste(length(unique(not_always_con))/(spe_consumer + spe_resource) * 100,"% of the species will be removed because there is some frames where they are not part of the giant component"))
  return(unique(not_always_con))
}
# sampled_netw
not_giant_compo <- connected_compo(simulated_network, nb_frame)
```

```{r}
filter_giant_component <- function(simu_netw, not_giant_compo){
  # On observed data
  simu_netw$obs_giant_compo <- lapply(simu_netw$obs_network, function(arr){
    arr[!dimnames(arr)[[1]] %in% unique(not_giant_compo),
        !dimnames(arr)[[2]] %in% unique(not_giant_compo)]
  })
  
  # On the trait matching matrix
  simu_netw$trait$trait_mat_giant_compo <- simu_netw$trait$matching_matrix[!dimnames(simu_netw$obs_network[[1]])[[1]] %in% unique(not_giant_compo),
                                                                                !dimnames(simu_netw$obs_network[[1]])[[2]] %in% unique(not_giant_compo)]
  
  # On the resource traits
  simu_netw$trait$resource_giant_compo <- simu_netw$trait$trait_resource[!dimnames(simu_netw$trait$trait_resource)[[1]] %in% unique(not_giant_compo),]
  
  #On the consumer traits
  simu_netw$trait$consumer_giant_compo <- simu_netw$trait$trait_consumer[!dimnames(simu_netw$trait$trait_consumer)[[1]] %in% unique(not_giant_compo),,]
  
  return(simu_netw)
}

simulated_network <- filter_giant_component(simulated_network, not_giant_compo)

# not_giant_compo
# simulated_network$trait$trait_mat_giant_compo

```


```{r}
ade4::table.value(simulated_network$obs_giant_compo[[1]])
```

```{r}
sampled_netw <- Reduce('+', simulated_network$obs_giant_compo)
# to keep only the connected species
sampled_netw_con <- sampled_netw[which(rowSums(sampled_netw) != 0), which(colSums(sampled_netw) != 0)]
component <- igraph::components(graph_from_incidence_matrix(sampled_netw_con))
if (length(component$csize) != 1) {
  print(paste("The network",i, "is not strongly connected, there is", component$no, "connected components"))
  print(names(component$membership[which(component$membership != which.max(component$csize))]))
  print("are not part of of the giant component.")
  not_always_con <- c(not_always_con, names(component$membership[which(component$membership != which.max(component$csize))]))
}
table.value(sampled_netw)

plot(graph_from_incidence_matrix(sampled_netw), vertex.size=5)
```

```{r}
igraph::degree(graph_from_incidence_matrix(sampled_netw))
```


```{r}
tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen

afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)

par(mfrow=c(2,2))
ade4::table.value(simulated_network$trait$trait_mat_giant_compo, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1]), csize = 0.8) # trait matching matrix et tri selon le premier axe
ade4::table.value(tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # réseau moyen observé
toto = reconst_afc(afc.tab, nf = 6) # pour reconstruire le réseau moyen à partir des positions sur l'AFC mais on voudrait plustôt obtenir le trait matching
ade4::table.value(toto, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1]), csize = 0.8) # plot le réseau reconstruit
ade4::table.value(afc.tab$tab, x = rank(afc.tab$co[,1]), y = rank(afc.tab$li[,1])) # transformed average table
```

```{r}
afc.tab=dudi.coa(tab, nf = 18, scannf = F)
```


```{r}
# toto = reconst_afc(afc.tab, nf = 4)
# plot(RV.randtest(toto, data.frame(simulated_network$trait$trait_mat_giant_compo), nrepet = 999))
# 
# rv <- RV.randtest(toto, data.frame(simulated_network$trait$trait_mat_giant_compo), nrepet = 999)
# 
# rv$obs
```

```{r}
library(ggplot2)
library(tidyr)
```

```{r}
toto = reconst_afc(afc.tab, nf = 12) # pour reconstruire le réseau moyen à partir des positions sur l'AFC mais on voudrait plustôt obtenir le trait matching
toto
toto$res <- rownames(toto)
reconstructed = pivot_longer(toto, cols = starts_with("con"), names_to = "con")
reconstructed$res <- as.factor(reconstructed$res)
reconstructed$con <- as.factor(reconstructed$con)
str(reconstructed)

# hist(reconstructed$value)

# reconstructed$value[which(reconstructed$value < 0)] <- 0

ggplot(reconstructed, aes(x = res, y = con, fill = value)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue")
```

```{r}
# ade4::table.value(simulated_network$trait$trait_mat_giant_compo[rank(afc.tab$li[,1]), rank(afc.tab$co[,1])])
# rank(afc.tab$li[,1])

trait_mat <- as.data.frame(simulated_network$trait$trait_mat_giant_compo)
trait_mat$res <- rownames(simulated_network$trait$trait_mat_giant_compo)
trait_mat <- pivot_longer(trait_mat, cols = starts_with("con"), names_to = "con")
trait_mat$res <- as.factor(trait_mat$res)
trait_mat$con <- as.factor(trait_mat$con)

ggplot(trait_mat, aes(x = res, y = con, fill = value)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue")
```


```{r}
# afc.tab$li

cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
```

```{r}
scatter(afc.tab)
```


```{r}
library(adegraphics)
# adegraphics::table.value(afc.tab$tab, coordsx = rank(afc.tab$co[,1]), coordsy  = rank(afc.tab$li[,1]), method = "color", ppoint.cex = 0.2) # transformed average table

image(simulated_network$trait$matching_matrix [order(afc.tab$li[,1]), order(afc.tab$co[,1])])

```


```{r}
tr1x1_line <- c()
tr1x2_line <- c()
tr1x3_line <- c()
tr1x4_line <- c()

tr2x1_line <- c()
tr2x2_line <- c()
tr2x3_line <- c()
tr2x4_line <- c()

tr1x1_col <- c()
tr1x2_col <- c()
tr1x3_col <- c()
tr1x4_col <- c()

tr2x1_col <- c()
tr2x2_col <- c()
tr2x3_col <- c()
tr2x4_col <- c()

for (i in 1:5) {
  nb_frame = 5
  spe_resource = 50
  spe_consumer = 100
  simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                     nb_location = nb_frame,
                                     know_env_grad_pos = F, ninter = 100, 
                                     mean_tol = 0.1, sd_tol = 0.1,
                                     mean_tol_env = 0.1, sd_tol_env = 0.1,
                                     delta = 1, corr_env_trait = 0,
                                     ratio_grad = 0.6)
  
  not_giant_compo <- connected_compo(simulated_network, nb_frame)
  simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
  
  
  tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
  afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)
  
  (corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li)) # resource correlation with the rows of the CA depending on the axis
  (corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co)) # consumer correlation with the columns of the CA depending on the axis
  
  tr1x1_line <- c(tr1x1_line, abs(corr_line[1,1]))
  tr1x2_line <- c(tr1x2_line, abs(corr_line[1,2]))
  tr1x3_line <- c(tr1x3_line, abs(corr_line[1,3]))
  tr1x4_line <- c(tr1x4_line, abs(corr_line[1,4]))
  
  tr2x1_line <- c(tr2x1_line, abs(corr_line[2,1]))
  tr2x2_line <- c(tr2x2_line, abs(corr_line[2,2]))
  tr2x3_line <- c(tr2x3_line, abs(corr_line[2,3]))
  tr2x4_line <- c(tr2x4_line, abs(corr_line[2,4]))

  tr1x1_col <- c(tr1x1_col, abs(corr_col[1,1]))
  tr1x2_col <- c(tr1x2_col, abs(corr_col[1,2]))
  tr1x3_col <- c(tr1x3_col, abs(corr_col[1,3]))
  tr1x4_col <- c(tr1x4_col, abs(corr_col[1,4]))
  
  tr2x1_col <- c(tr2x1_col, abs(corr_col[2,1]))
  tr2x2_col <- c(tr2x2_col, abs(corr_col[2,2]))
  tr2x3_col <- c(tr2x3_col, abs(corr_col[2,3]))
  tr2x4_col <- c(tr2x4_col, abs(corr_col[2,4]))
  
  s.corcircle(corr_line)
  s.corcircle(corr_col)
  scatter(afc.tab)
}
# par(mfrow = c(2,1))
boxplot(tr1x1_line, tr1x2_line, tr1x3_line, tr1x4_line, names = c("Tr1 axe1", "Tr1 axe2", "Tr1 axe3", "Tr1 axe4"), main = "Correlation between trait 1 and axes for line species (res)", ylim = c(0,1))
boxplot(tr1x1_line, tr2x2_line, tr2x3_line, tr2x4_line, names = c("Tr2 axe1", "Tr2 axe2", "Tr2 axe3", "Tr2 axe4"), main = "Correlation between trait 2 and axes for line species (res)", ylim = c(0,1))

boxplot(tr1x1_col, tr1x2_col, tr1x3_col, tr1x4_col, names = c("Tr1 axe1", "Tr1 axe2", "Tr1 axe3", "Tr1 axe4"), main = "Correlation between trait 1 and axes for column species (con)", ylim = c(0,1))
boxplot(tr1x1_col, tr2x2_col, tr2x3_col, tr2x4_col, names = c("Tr2 axe1", "Tr2 axe2", "Tr2 axe3", "Tr2 axe4"), main = "Correlation between trait 2 and axes for column species (con)", ylim = c(0,1))

```

```{r}
s.corcircle(cor(simulated_network$trait$resource_giant_compo, afc.tab$li))
```


# Take care of the weird axes

```{r}
nb_frame = 20
spe_resource = 50
spe_consumer = 50
simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                   nb_location = nb_frame,
                                   know_env_grad_pos = T, ninter = 5000, 
                                   mean_tol = 0.1, sd_tol = 0.1,
                                   mean_tol_env = 0.1, sd_tol_env = 0.1,
                                   delta = 1, corr_env_trait = 0,
                                   ratio_grad = 0.7)

not_giant_compo <- connected_compo(simulated_network, nb_frame)
simulated_network <- filter_giant_component(simulated_network, not_giant_compo)


tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)

(corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li)) # resource correlation with the rows of the CA depending on the axis
(corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co)) # consumer correlation with the columns of the CA depending on the axis

plot(RV.randtest(data.frame(simulated_network$trait$resource_giant_compo), afc.tab$li))
plot(RV.randtest(data.frame(simulated_network$trait$consumer_giant_compo), afc.tab$co))

s.corcircle(corr_line)
s.corcircle(corr_col)
ade4::table.value(tab, clegend = 0)
scatter(afc.tab)


centrality <- igraph::closeness(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))

sort(centrality)
# color depending on the centrality
fine = 10 # this will adjust the resolving power.
pal = colorRampPalette(c('red','green'))

#this gives you the colors you want for every point
graphCol = pal(fine)[as.numeric(cut(log(centrality),breaks = fine))]

# now you just need to plot it with those colors
plot(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]), vertex.size=5, vertex.color=graphCol)

# plot(graph_from_incidence_matrix(simulated_network$obs_giant_compo[[1]][]))

# for (i in 1:nb_frame){
#   print(simulated_network$obs_giant_compo[[i]]["res33", "con17"])
# }

# closeness(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))
# sort(closeness(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0])))

which(igraph::degree(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))>5)
igraph::degree(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))>5

fou1 = foucart(lapply(simulated_network$obs_giant_compo, as.data.frame), scannf = F, nf = 5)
plot(fou1, xax = 1)

# boxplot.stats(afc.tab$l1[,"RS2"])
ax_position <- afc.tab$l1[,"RS1"]
# which(ax_position < quantile(ax_position, 0.025))
# which(ax_position > quantile(ax_position, 0.975))
which(ax_position < mean(ax_position) - 3 * sd(ax_position))
which(ax_position >mean(ax_position) + 3 * sd(ax_position))
afc.tab$l1
hist(ax_position)
quantile(ax_position)

ax_position <- afc.tab$c1[,"CS1"]
# which(ax_position < quantile(ax_position, 0.025))
# which(ax_position > quantile(ax_position, 0.975))
which(ax_position < mean(ax_position) - 3 * sd(ax_position))
which(ax_position >mean(ax_position) + 3 * sd(ax_position))
afc.tab$c1
hist(ax_position)
quantile(ax_position)

cluster_spe <- cluster_edge_betweenness(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))
dendPlot(cluster_spe)

barplot(fou1$eig)
table.value(ifelse(tab> 0, 1,0), ppoint.cex=0.5)
```


```{r}
s.arrow(diag(sqrt(fou1$cw)) %*% as.matrix(fou1$c1), label = rownames(fou1$l1))
s.label(fou1$li, add.plot = TRUE)

## à faire avec foucart

cor(diag(sqrt(fou1$cw)) %*% as.matrix(fou1$c1), simulated_network$trait$resource_giant_compo)

hist(simulated_network$trait$resource_giant_compo)

## second
s.arrow(diag(sqrt(fou1$lw)) %*% as.matrix(fou1$l1), label = rownames(fou1$l1))
s.label(fou1$co, add.plot = TRUE)
```


```{r}
transitivity(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]), type = "barrat")
```

```{r}
cluster_spe <- cluster_louvain(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))
cluster_spe$membership
palette <- rainbow(max(cluster_spe$membership))
plot(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]), vertex.size=5, vertex.color = palette[cluster_spe$membership])
```
```{r}
cluster_spe <- cluster_edge_betweenness(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]))
dendPlot(cluster_spe)
cluster_spe$membership
palette <- rainbow(max(cluster_spe$membership))
plot(graph_from_incidence_matrix(tab[rowSums(tab) != 0, colSums(tab) != 0]), vertex.size=5, vertex.color = palette[cluster_spe$membership])
dendPlot(cluster_spe)
```


```{r}
print("for consummer")
vert_a = names(which(igraph::degree(graph_from_incidence_matrix(tab)) == 1))
vert_a_con <- grep("con", vert_a, value = T)
conn_vert_b_con <- c()
vert_b_res <- c()
vert_a_b_con <- c()
for(a in vert_a_con){
  vert_a_b_con <- c(vert_a_b_con, tab[which(tab[,a] !=0), a])
  conn_vert_b_con <- c(conn_vert_b_con, rowSums(tab)[names(which(tab[,a] !=0))])
}
vert_a_con
vert_a_b_con
conn_vert_b_con


print("for resource")
vert_a = names(which(igraph::degree(graph_from_incidence_matrix(tab)) == 1))
vert_a_res <- grep("res", vert_a, value = T)
conn_vert_b_res <- c()
vert_b_res <- c()
vert_a_b_res <- c()
for(a in vert_a_res){
  vert_a_b_res <- c(vert_a_b_res, tab[a, which(tab[a,] !=0)])
  conn_vert_b_res <- c(conn_vert_b_res, colSums(tab)[names(which(tab[a,] !=0))])
}
vert_a_res
vert_a_b_res
conn_vert_b_res

```

```{r}
filt_netw <- rep(list(NA), nb_frame)
for (i in 1:nb_frame) {
  filt_netw[[i]] <- simulated_network$obs_giant_compo[[1]][,-which(colnames(simulated_network$obs_giant_compo[[1]]) == "con17")]
}
# filt_netw
fou1 = foucart(lapply(filt_netw, as.data.frame), scannf = F, nf = 5)
plot(fou1)
```


# correlation trait matching reconstruit et th

```{r}
rv_distrib <- c()
for (i in 1:30) {
  nb_frame = 10
  spe_resource = 50
  spe_consumer = 50
  simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                     nb_location = nb_frame,
                                     know_env_grad_pos = T, ninter = 5000, 
                                     mean_tol = 0.1, sd_tol = 0.1,
                                     mean_tol_env = 0.1, sd_tol_env = 0.1,
                                     delta = 1, corr_env_trait = 0,
                                     ratio_grad = 0.7)
  
  not_giant_compo <- connected_compo(simulated_network, nb_frame)
  simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
  
  
  tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
  afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)
  
  toto = reconst_afc(afc.tab, nf = 4)
  
  # plot(RV.randtest(toto, data.frame(simulated_network$trait$trait_mat_giant_compo), nrepet = 999))
  
  rv <- RV.randtest(toto, data.frame(simulated_network$trait$trait_mat_giant_compo), nrepet = 100)
  
  rv_distrib <- c(rv_distrib, rv$obs)
  # rv$obs 
}
hist(rv_distrib)
median(rv_distrib)
```


# For différent parameters, try out the correlation between the reconsytructed axes and the theoritical traits

```{r}
num_simu = 10
tr1ax1 <- c()
tr2ax2 <- c()
rv_distrib <- c()
ratio_grad = 0.7
mean_tol_env = 0.1
ninter = 2500
nb_frame = 2

for (i in 1:50) {
  spe_resource = 50
  spe_consumer = 50
  simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                     nb_location = nb_frame,
                                     know_env_grad_pos = T, ninter = ninter, 
                                     mean_tol = 0.1, sd_tol = 0.1,
                                     mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                     delta = 1, corr_env_trait = 0,
                                     ratio_grad = ratio_grad)
  
  not_giant_compo <- connected_compo(simulated_network, nb_frame)
  simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
  
  
  tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
  afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)
  
    
  corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
  corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
  tr1ax1 <- c(tr1ax1, corr_line[1,1])
  tr2ax2 <- c(tr2ax2, corr_line[2,2])
}
print(tr1ax1)
# jpeg(file= paste0("~/Images/trait_reconstruction_performance/simu",num_simu,"_1.jpeg"))
boxplot(abs(tr1ax1), ylim = c(0,1), main = paste0("Absolute correlation between trait 1 and ax 1 when the \n environement variance is ", mean_tol_env, " folds the gradient size (flat distrib) \n ratio_grad = ", ratio_grad, ", ", nb_frame, " frames, ", ninter, " obs each"))
# dev.off()

print(tr2ax2)
# jpeg(file= paste0("~/Images/trait_reconstruction_performance/simu",num_simu,"_2.jpeg"))
boxplot(abs(tr2ax2), ylim = c(0,1), main = paste0("Absolute correlation between trait 2 and ax 2 when the \n environement variance is ", mean_tol_env, " folds the gradient size (flat distrib) \n ratio_grad = ", ratio_grad, ", ", nb_frame, " frames, ", ninter, " obs each"))
# dev.off()

num_simu = num_simu + 1
```

```{r}
num_simu = 100
tr1ax1 <- c()
tr2ax2 <- c()
ratio_grad = 0.5
mean_tol_env = 0.7
nb_frame = 5
ninter = 50 * 50 * 10 / nb_frame

for (i in 1:50) {
  spe_resource = 50
  spe_consumer = 50
  simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                     nb_location = nb_frame,
                                     know_env_grad_pos = T, ninter = ninter, 
                                     mean_tol = 0.1, sd_tol = 0.1,
                                     mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                     delta = 0.1, corr_env_trait = 0,
                                     ratio_grad = ratio_grad)
  
  not_giant_compo <- connected_compo(simulated_network, nb_frame)
  simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
  
  
  tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
  afc.tab=dudi.coa(tab, nf = 18, scannf = FALSE)
  
    
  corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
  corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
  tr1ax1 <- c(tr1ax1, corr_line[1,1])
  tr2ax2 <- c(tr2ax2, corr_line[2,2])
}
print(tr1ax1)
boxplot(abs(tr1ax1), ylim = c(0,1), main = paste0("Absolute correlation between trait 1 and ax 1 when the \n environement variance is ", mean_tol_env, " folds the gradient size (flat distrib) \n ratio_grad = ", ratio_grad, ", ", nb_frame, " frames, ", ninter, " obs each"))

print(tr2ax2)
boxplot(abs(tr2ax2), ylim = c(0,1), main = paste0("Absolute correlation between trait 2 and ax 2 when the \n environement variance is ", mean_tol_env, " folds the gradient size (flat distrib) \n ratio_grad = ", ratio_grad, ", ", nb_frame, " frames, ", ninter, " obs each"))

```


## test of mean_tol_env

```{r}
parameters <- c(0.01, 0.1, 1, 10, 100)
nb_rep = 30


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  # mean_tol_env = 0.1
  mean_tol_env = param
  ninter = 2500
  nb_frame = 2
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = 0.1, corr_env_trait = 0,
                                       ratio_grad = ratio_grad,
                                       magn_res_max = 20000)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on mean tol env")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1),main = "Optimum trait 2 ax 2 correlation depending on mean tol env")
```

The correlation decreases when the mean_tol_env gets too high because, the consumers are gathered across a bigger niche and hence, there is less and maybe a sampling effect, we just need to increase magn_res_max

## test ninter

```{r}
parameters <- c(300, 3000, 30000)
nb_rep = 50


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = 0.3
  nb_frame = 5
  ninter = param / nb_frame
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.05,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.2,
                                       delta = 0.2, corr_env_trait = 0,
                                       ratio_grad = ratio_grad)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    print(param)
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
    
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on \n the   number of observations per frames")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1),main = "Optimum trait 2 ax 2 correlation depending on \n the number of observations per frames")
```

## test crossed effect nb_frame x mean_tol_env

```{r}
library(ggplot2)
frames <- c(1, 2, 3, 5, 7, 10)
tol_env <- c(0.1, 0.2, 0.3, 0.5, 0.7, 1)
nb_rep = 10

effect_tol_frame_1 = expand.grid(frame = frames, tol_env = tol_env)
effect_tol_frame_2 = expand.grid(frame = frames, tol_env = tol_env)

effect_tol_frame_1$mean_corr = 0
effect_tol_frame_2$mean_corr = 0


for (r in 1:nrow(effect_tol_frame_1)) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = effect_tol_frame_1$tol_env[r]
  ninter = 5000 / effect_tol_frame_1$frame[r]
  # ninter = param
  nb_frame = effect_tol_frame_1$frame[r]
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.05,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.2,
                                       delta = 0.2, corr_env_trait = 0,
                                       ratio_grad = ratio_grad)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
    
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
    # print(r)
  }
  effect_tol_frame_1$mean_corr[r] <- mean(abs(tr1ax1))
  effect_tol_frame_2$mean_corr[r] <- mean(abs(tr2ax2))
  
}

ggplot(effect_tol_frame_1, aes(x = as.factor(frame), y = as.factor(tol_env), fill = mean_corr)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue", limits = c(0, 1)) + labs(x = "number of frame",y = "mean tolerance of the env niche") + ggtitle("Trait recovering performance depending on the number of frames and the \n tolerence of the species toward the environment (axis1)") + geom_text(aes(label=round(mean_corr, 2)))

ggplot(effect_tol_frame_2, aes(x = as.factor(frame), y = as.factor(tol_env), fill = mean_corr)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue", limits = c(0, 1)) + labs(x = "number of frame",y = "mean tolerance of the env niche") + ggtitle("Trait recovering performance depending on the number of frames and the \n tolerence of the species toward the environment (axis2)") + geom_text(aes(label=round(mean_corr, 2)))
```

```{r}
library(ggplot2)
frames <- c(1, 2, 3, 5, 7, 10)
tol_env <- c(0.1, 0.2, 0.3, 0.5, 0.7, 1)
nb_rep = 10

effect_tol_frame_1 = expand.grid(frame = frames, tol_env = tol_env)
effect_tol_frame_2 = expand.grid(frame = frames, tol_env = tol_env)

effect_tol_frame_1$mean_corr = 0
effect_tol_frame_2$mean_corr = 0

for (r in 1:nrow(effect_tol_frame_1)) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = effect_tol_frame_1$tol_env[r]
  ninter = 5000 / effect_tol_frame_1$frame[r]
  # ninter = param
  nb_frame = effect_tol_frame_1$frame[r]
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.05,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.2,
                                       delta = 0.2, corr_env_trait = 0,
                                       ratio_grad = ratio_grad)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
    
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
    # print(r)
  }
  effect_tol_frame_1$mean_corr[r] <- sd(abs(tr1ax1)) / mean(abs(tr1ax1)) *100
  effect_tol_frame_2$mean_corr[r] <- sd(abs(tr2ax2)) / mean(abs(tr2ax2)) * 100
  
}

ggplot(effect_tol_frame_1, aes(x = as.factor(frame), y = as.factor(tol_env), fill = mean_corr)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue", limits = c(0, 100)) + labs(x = "number of frame",y = "mean tolerance of the env niche") + ggtitle("Trait recovering performance depending on the number of frames and the \n tolerence of the species toward the environment (axis1)") + geom_text(aes(label=round(mean_corr, 2)))

ggplot(effect_tol_frame_2, aes(x = as.factor(frame), y = as.factor(tol_env), fill = mean_corr)) + geom_tile() + scale_fill_gradient(low = "white", high = "blue", limits = c(0, 100)) + labs(x = "number of frame",y = "mean tolerance of the env niche") + ggtitle("Trait recovering performance depending on the number of frames and the \n tolerence of the species toward the environment (axis2)") + geom_text(aes(label=round(mean_corr, 2)))
```

## test nb_frames

```{r}
parameters <- c(2, 4, 10, 20)
nb_rep = 30


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = 0.7
  ninter = 2500 / param
  nb_frame = param
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 50
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = 1, corr_env_trait = 0,
                                       ratio_grad = ratio_grad)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on \n the   number of frames")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1),main = "Optimum trait 2 ax 2 correlation depending on \n the number of frames")
```

## test delta

```{r}
parameters <- c(0, 0.01, 0.1, 0.2, 1, 2)
nb_rep = 30


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = 1
  ninter = 2500
  nb_frame = 2
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 50
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = param, corr_env_trait = 0,
                                       ratio_grad = ratio_grad,
                                       magn_res_max = 20000)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on delta")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1), main = "Optimum trait 2 ax 2 correlation depending on delta")
```

## test ratio_grad

```{r}

parameters <- c(0.1, 0.3, 0.5, 0.7, 0.9)
nb_rep = 30


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = param
  mean_tol_env = 0.7
  nb_frame = 5
  ninter = 5000 / nb_frame
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = 0.2, corr_env_trait = 0,
                                       ratio_grad = ratio_grad,
                                       magn_res_max = 20000)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on trait importance ratio")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1), main = "Optimum trait 2 ax 2 correlation depending on trait importance ratio")
```

## test mean_tol

```{r}
parameters <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5)
nb_rep = 50


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.5
  mean_tol_env = 0.7
  nb_frame = 5
  ninter = 5000 / nb_frame
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 60
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = param, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = 0.2, corr_env_trait = 0,
                                       ratio_grad = ratio_grad,
                                       magn_res_max = 20000)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on mean_tol trait")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1), main = "Optimum trait 2 ax 2 correlation depending on mean_tol trait")
```


# Tester empiriquement reconstruction traits depuis trait matching th

```{r}
ratio_grad = 0.7
mean_tol_env = 0.1
ninter = 2500
nb_frame = 10

spe_resource = 50
spe_consumer = 50
simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                   nb_location = nb_frame,
                                   know_env_grad_pos = T, ninter = ninter, 
                                   mean_tol = 0.7, sd_tol = 0.1,
                                   mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                   delta = 1, corr_env_trait = 0,
                                   ratio_grad = ratio_grad)

not_giant_compo <- connected_compo(simulated_network, nb_frame)
simulated_network <- filter_giant_component(simulated_network, not_giant_compo)

ade4::table.value(simulated_network$trait$matching_matrix)

############################# avec log ###########################################
# 
# afc.tab=dudi.coa(log(simulated_network$trait$matching_matrix + 1), nf = 4, scannf = F)
# # afc.tab=dudi.coa(simulated_network$trait$matching_matrix, nf = 4, scannf = F)
# 
# reconst_trait_match = reconst_afc(afc.tab, nf = 4) 
# 
# ade4::table.value(reconst_trait_match)
# 
# column_corr <- sapply(1:ncol(reconst_trait_match), function(i) {
#     cor(reconst_trait_match[,i], simulated_network$trait$matching_matrix[,i])
#   })
# 
# boxplot(column_corr, ylim = c(0, 1))
# 
# corr_line <- cor(simulated_network$trait$trait_resource, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
# corr_col <- cor(simulated_network$trait$trait_consumer[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
# 
# print(corr_col)
# print(corr_line)
# 
# scatter(afc.tab)
# 
# # log(matrix(c(1:25), ncol = 5, nrow = 5)) + 1

################################ sans log ###########################################

afc.tab=dudi.coa(simulated_network$trait$matching_matrix, nf = 4, scannf = F)

reconst_trait_match = reconst_afc(afc.tab, nf = 4) 

ade4::table.value(reconst_trait_match)

column_corr <- sapply(1:ncol(reconst_trait_match), function(i) {
    cor(reconst_trait_match[,i], simulated_network$trait$matching_matrix[,i])
  })

boxplot(column_corr, ylim = c(0, 1))

corr_line <- cor(simulated_network$trait$trait_resource, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
corr_col <- cor(simulated_network$trait$trait_consumer[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis

print(corr_col)
print(corr_line)

scatter(afc.tab)

# log(matrix(c(1:25), ncol = 5, nrow = 5)) + 1
```

# representation with bipartite

```{r}
library(bipartite)

ratio_grad = 0.7
mean_tol_env = 0.1
ninter = 5000
nb_frame = 2

col_corr_mean <- c()
col_corr_median <- c()

spe_resource = 75
spe_consumer = 75
simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                   nb_location = nb_frame,
                                   know_env_grad_pos = T, ninter = ninter, 
                                   mean_tol = 0.1, sd_tol = 0.05,
                                   mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                   delta = 1, corr_env_trait = 0,
                                   ratio_grad = ratio_grad)

not_giant_compo <- connected_compo(simulated_network, nb_frame)
simulated_network <- filter_giant_component(simulated_network, not_giant_compo)

tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen

# visweb(simulated_network$obs_giant_compo[[1]])

for(i in 1:nb_frame){
  plotweb(simulated_network$obs_giant_compo[[i]])
}

visweb(tab, type = "diagonal", square = "compartment", box.border = "white", frame = T)
# plotweb(tab)
```

```{r}
visweb(matrix(runif(900, 0, 10), nrow = 30, ncol = 30), type = "diagonal")
```


```{r}
parameters <- c(0, 0.01, 0.1, 1, 2)
nb_rep = 30


param_tr1ax1 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr1ax1) <- as.character(parameters)

param_tr2ax2 <- data.frame(matrix(ncol = length(parameters), nrow = nb_rep))
colnames(param_tr2ax2) <- as.character(parameters)

for (param in parameters) {
  tr1ax1 <- c()
  tr2ax2 <- c()
  rv_distrib <- c()
  ratio_grad = 0.7
  mean_tol_env = 1
  ninter = 2500
  nb_frame = 2
  
  for (i in 1:nb_rep) {
    spe_resource = 50
    spe_consumer = 50
    simulated_network <- env_grad_netw(nb_resource = spe_resource , nb_consumer = spe_consumer,
                                       nb_location = nb_frame,
                                       know_env_grad_pos = T, ninter = ninter, 
                                       mean_tol = 0.1, sd_tol = 0.1,
                                       mean_tol_env = mean_tol_env, sd_tol_env = 0.1,
                                       delta = param, corr_env_trait = 0,
                                       ratio_grad = ratio_grad,
                                       magn_res_max = 20000)
    
    not_giant_compo <- connected_compo(simulated_network, nb_frame)
    simulated_network <- filter_giant_component(simulated_network, not_giant_compo)
    
    
    tab = Reduce('+', simulated_network$obs_giant_compo) # afin de générer le réseau moyen
    afc.tab=dudi.coa(tab, nf = 10, scannf = FALSE)
    
      
    corr_line <- cor(simulated_network$trait$resource_giant_compo, afc.tab$li) # resource correlation with the rows of the CA depending on the axis
    corr_col <- cor(simulated_network$trait$consumer_giant_compo[,1,], afc.tab$co) # consumer correlation with the columns of the CA depending on the axis
    tr1ax1 <- c(tr1ax1, corr_line[1,1])
    tr2ax2 <- c(tr2ax2, corr_line[2,2])
  }
  param_tr1ax1[,as.character(param)] <- abs(tr1ax1)
  param_tr2ax2[,as.character(param)] <- abs(tr2ax2)
  
}
# param_tr1ax1
boxplot(param_tr1ax1, ylim = c(0, 1), main = "Optimum trait 1 ax 1 correlation depending on delta")
# param_tr2ax2
boxplot(param_tr2ax2, ylim = c(0, 1), main = "Optimum trait 2 ax 2 correlation depending on delta")
```

# calcul hypervolume

```{r}
library(cxhull)
points <- rbind(
c(0.5,0.5,0.5),
c(0,0,0),
c(0,0,1),
c(0,1,0),
c(0,1,1),
c(1,0,0),
c(1,0,1),
c(1,1,0),
c(1,1,1)
)
hull <- cxhull(points)

hull$volume
```


# Compute frame position variance

$Distance_i = \sqrt{\sum{(coordinate_i - coordinate_{barycenter})}^2}$

```{r}
######################## Compute barycentre #####################
nb_pt <- 500000
# pt <- matrix(runif(nb_pt, 0, 20), ncol = 2)
pt <- matrix(rnorm(nb_pt, 0, 1), ncol = 2)

barycenter <- c(mean(pt[,1]), mean(pt[,2]))

plot(x = pt[,1], y = pt[,2])
points(barycenter[1], barycenter[2], col = "red")

# sum(pt[,1] - barycenter[1])
# sum(pt[,2] - barycenter[2])

colSums(sweep(pt, 2, barycenter, FUN = "-")) # same but everything at once

######################### Compute distance #######################

dist <- sqrt(rowSums((sweep(pt, 2, barycenter, FUN = "-"))^2))
pt_sd <- sd(dist)

hist(dist)

sum(dist)
sum(exp(dist))
```


```{r}
n_dim = 2
test_mat <- matrix(rnorm(10 * n_dim, mean = 1, sd = 2), ncol = n_dim)
plot(test_mat[, 1], test_mat[, 2])


colMeans(test_mat)
test_mat
sweep(test_mat, 2, colMeans(test_mat), FUN = "-")
sweep(test_mat, 2, colMeans(test_mat), FUN = "-")**2
rowSums(sweep(test_mat, 2, colMeans(test_mat), FUN = "-")**2)
sqrt(rowSums(sweep(test_mat, 2, colMeans(test_mat), FUN = "-")**2))


dist <- sqrt(rowSums(sweep(test_mat, 2, colMeans(test_mat), FUN = "-")**2))
hist(dist)
```

```{r}
set_values <- rnorm(10000)
dist_1 <- (set_values - mean(set_values))**2

set_values <- rnorm(10000)
dist_2 <- (set_values - mean(set_values))**2

set_values <- rnorm(10000)
dist_3 <- (set_values - mean(set_values))**2

set_values <- rnorm(10000)
dist_4 <- (set_values - mean(set_values))**2

set_values <- rnorm(10000)
dist_5 <- (set_values - mean(set_values))**2

dist <- dist_1 + dist_2 + dist_3 + dist_4 + dist_5

hist(dist)

# hist(sqrt((set_values - mean(set_values))**2))
# hist(abs(rnorm(10000)))
```

```{r}
set_values <- abs(rnorm(100))
dist <- (set_values - mean(set_values))**2
values <- dist
for( i in 1:1000){
  set_values <- abs(rnorm(10000))
  dist <- (set_values - mean(set_values))**2
  values <- values + dist
}
hist(values)
```


# Variance of the position in the Correspondance Analysis

```{r}
simu_network <- env_grad_netw(nb_resource = 200, nb_consumer = 200, nb_location = 10,
              ninter = 40000,
              mean_tol_env = 0.7, mean_tol = 0.1,
              ratio_grad = 0.5, delta = 0.2)
```

```{r}
not_giant_compo <- connected_compo(simu_network, nb_frame)
simu_network <- filter_giant_component(simu_network, not_giant_compo)
tab = Reduce('+', simu_network$obs_giant_compo) # afin de générer le réseau moyen
afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
scatter(afc.tab)
```

## Mean position in AFC

```{r}
afc.tab$li
afc.tab$co
```

## Position in the different frames

Here, in fou1\$Tli and fou1\$Tco the structure is res"i".Ana"j" where i is the species numlber and j the frame number.


```{r}
fou1 = foucart(lapply(simu_network$obs_network, as.data.frame), scannf = F, nf = 2)
fou1$Tli
fou1$Tco
```

## extract the positions in the different frames for each species

### Axis 1

```{r}
library(stringr)

# for resources
res_var <- c()
for (res in 1:200) {
  res1 <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var <- c(res_var, sd(res1[, 1]))
}
hist(res_var, breaks = 20)
boxplot(res_var)

# for consumers 
con_var <- c()
for (con in 1:200) {
  con1 <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var <- c(con_var, sd(con1[, 1]))
}
hist(con_var, breaks = 20)
boxplot(con_var)
```

### Axis 2

```{r}
# for resources
res_var <- c()
for (res in 1:100) {
  res1 <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var <- c(res_var, sd(res1[, 2]))
}
hist(res_var, breaks = 20)
boxplot(res_var)

# for consumers 
con_var <- c()
for (con in 1:100) {
  con1 <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var <- c(con_var, sd(con1[, 2]))
}
hist(con_var, breaks = 20)
boxplot(con_var)
```

## jaccard distance

be careful, the distances are under the form, $d = \sqrt{1-s}$ hence we really have a dissimilarity coefficient. Hence 0 is identical and 1 is completely different.

It is going to look at the distance between the of the resources presence along the frame for each consumer and vice versa

```{r}
seq_table <- matrix(c(1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0), byrow = T, nrow = 5)
dimnames(seq_table)[[1]] <- c("res1", "res2", "res3", "res4", "res5")
dimnames(seq_table)[[2]] <- c("frame1", "frame2", "frame3", "frame4")
seq_table
t(seq_table)
dist.binary(seq_table, method = 1)
dist.binary(t(seq_table), method = 1)
sum(dist.binary(seq_table, method = 1))
```

### convert the list of arrays into a 3D array

```{r}
a <- list(matrix(1:10, nrow = 2, byrow = T),
          matrix(11:20, nrow = 2, byrow = T),
          matrix(21:30, nrow = 2, byrow = T))
b <- array(unlist(a), dim = c(2,5,3))
print(b)
```

### convert to 3D array and keep the names

```{r}
array_3d <- array(unlist(simu_network$obs_network),
                  dim = c(nrow(simu_network$obs_network[[1]]),
                          ncol(simu_network$obs_network[[1]]),
                          length(simu_network$obs_network)))

dimnames(array_3d)[[1]] <- rownames(simu_network$obs_network[[1]])
dimnames(array_3d)[[2]] <- colnames(simu_network$obs_network[[1]])
dimnames(array_3d)[[3]] <- paste0("frame",1:length(simu_network$obs_network))
# array_3d
```

```{r}
sum(dist.binary(array_3d[,,1], method = 1)) # sum of the distances using the jaccard distance
sum(array_3d["res1",,]) # number of observation for this specie
```

#### Compute Jaccard dissimilarity and variance of the position distance

```{r}
##################### jaccard's distance #####################
# Initiate an empty matrix to 
res_dist <- array(rep(0, nrow(simu_network$obs_network[[1]])*2),
                  dim = c(nrow(simu_network$obs_network[[1]]),2)) # empty array of two columns
colnames(res_dist) <- c("dist", "obs")
rownames(res_dist) <- rownames(simu_network$obs_network[[1]])

# fill the empty array using the jaccard method and the number of observations for the interaction
# dimnames(res_dist)[1] <- c("dist", "nb_obs")
for (res in 1:nrow(simu_network$obs_network[[1]])) {
  res_dist[res, "dist"] = sum(dist.binary(t(array_3d[res,,]), method = 1), na.rm = T) # sum of the distances
  res_dist[res, "obs"] = sum(array_3d[res,,]) # number of interactions observed for this specie
}

# Initiate an empty matrix to 
con_dist <- array(rep(0, ncol(simu_network$obs_network[[1]])*2),
                  dim = c(ncol(simu_network$obs_network[[1]]),2))
colnames(con_dist) <- c("dist", "obs")
rownames(con_dist) <- colnames(simu_network$obs_network[[1]])

# fill the empty array using the jaccard method and the number of observations for the interaction
# dimnames(res_dist)[1] <- c("dist", "nb_obs")
for (con in 1:ncol(simu_network$obs_network[[1]])) {
  con_dist[con,"dist"] = sum(dist.binary(t(array_3d[,con,]), method = 1), na.rm = T) # sum of the distances
  con_dist[con, "obs"] = sum(array_3d[,con,]) # number of interactions observed for this specie
}
```


```{r}
##################### variance in CA #####################
# variance of the positions in the CA for resources
res_var_ax1 <- c()
res_var_ax2 <- c()
for (res in 1:nrow(simu_network$obs_network[[1]])) {
  res_position <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var_ax1 <- c(res_var_ax1, sd(res_position[, 1]))
  res_var_ax2 <- c(res_var_ax2, sd(res_position[, 2]))
}

# variance of the positions in the CA for consumers 
con_var_ax1 <- c()
con_var_ax2 <- c()
for (con in 1:ncol(simu_network$obs_network[[1]])) {
  con_position <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var_ax1 <- c(con_var_ax1, sd(con_position[, 1]))
  con_var_ax2 <- c(con_var_ax2, sd(con_position[, 2]))
}
# fou1$Tli

res_dist <- cbind(res_dist, res_var_ax1, res_var_ax2)
con_dist <- cbind(con_dist, con_var_ax1, con_var_ax2)
# con_dist
# res_dist
```


#### Resources

```{r}
# In black and white
ggplot() +
  geom_point(data = as.data.frame(res_dist), aes(x = dist, y = res_var_ax1, alpha = 0.6, size =  obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("resource variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 1 position for resource") +  # Add plot title
  scale_alpha_continuous(range = c(0.1, 1), name = "nb obs") +  # Adjust transparency range (optional)
  theme_bw()

# In colors
# Axis 1
ggplot() +
  geom_point(data = as.data.frame(res_dist), aes(x = dist, y = res_var_ax1, colour = obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("resource variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 1 position for resource") +  # Add plot title
  scale_colour_gradient(low = "cornflowerblue", high = "coral3", name = "nb obs") +
  theme_bw()

# Axis 1
ggplot() +
  geom_point(data = as.data.frame(res_dist), aes(x = dist, y = res_var_ax1, colour = obs, alpha = 0.6, size =  obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("resource variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 1 position for resource") +  # Add plot title
  scale_colour_gradient(low = "cornflowerblue", high = "brown3", name = "nb obs") +
  theme_bw()

# Axis 2
ggplot() +
  geom_point(data = as.data.frame(res_dist), aes(x = dist, y = res_var_ax2, colour = obs, alpha = 0.6, size =  obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("resource variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 2 position for resource") +  # Add plot title
  scale_colour_gradient(low = "#66CCEE", high = "navy", name = "nb obs") +
  theme_bw()

```


```{r}
ggplot() +
  geom_point(data = as.data.frame(res_dist), aes(x = obs, y = dist)) +
  xlab("nb obs") +  # Add X axis label
  ylab("jaccard dissimilarity") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs number of observations for resource") +  # Add plot title
  theme_bw()

ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = obs, y = dist)) +
  xlab("nb obs") +  # Add X axis label
  ylab("jaccard dissimilarity") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs number of observations for consumer") +  # Add plot title
  theme_bw()
```


#### Consumers
```{r}
# In colors
# Axis 1
ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = dist, y = con_var_ax1, colour = obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("consumer variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 1 position for consumer") +  # Add plot title
  scale_colour_gradient(low = "cornflowerblue", high = "coral3", name = "nb obs")

ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = dist, y = con_var_ax1, colour = obs, alpha = 0.6, size =  obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("consumer variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 1 position for consumer") +  # Add plot title
  scale_colour_gradient(low = "#66CCEE", high = "navy", name = "nb obs")

# Axis 2
ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = dist, y = res_var_ax2, colour = obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("consumer variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 2 position for consumer") +  # Add plot title
  scale_colour_gradient(low = "cornflowerblue", high = "coral3", name = "nb obs")

# Axis 2
ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = dist, y = res_var_ax2, colour = obs, alpha = 0.6, size =  obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("consumer variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 2 position for consumer") +  # Add plot title
  scale_colour_gradient(low = "#88CCEE", high = "#0200A0", name = "nb obs")

# Axis 2
ggplot() +
  geom_point(data = as.data.frame(con_dist), aes(x = dist, y = res_var_ax2, colour = obs)) +
  xlab("jaccard dissimilarity") +  # Add X axis label
  ylab("consumer variance on axis 1") +  # Add Y axis label
  ggtitle("Jaccard dissimilarity vs variance in axis 2 position for consumer") +  # Add plot title
  scale_colour_gradient(low = "#298c8c", high = "#800074", name = "nb obs")

```

## Merge information from both axis

```{r}
##################### variance in CA #####################
# variance of the positions in the CA for resources
res_var_ax1 <- c()
res_var_ax2 <- c()
for (res in 1:nrow(simu_network$obs_network[[1]])) {
  res_position <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var_ax1 <- c(res_var_ax1, sd(res_position[, 1]))
  res_var_ax2 <- c(res_var_ax2, sd(res_position[, 2]))
}

res_var <- res_var_ax1 * fou1$eig[1] + res_var_ax2 * fou1$eig[2]

# variance of the positions in the CA for consumers 
con_var_ax1 <- c()
con_var_ax2 <- c()
for (con in 1:ncol(simu_network$obs_network[[1]])) {
  con_position <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var_ax1 <- c(con_var_ax1, sd(con_position[, 1]))
  con_var_ax2 <- c(con_var_ax2, sd(con_position[, 2]))
}
# fou1$Tli

con_var <- con_var_ax1 * fou1$eig[1] + con_var_ax2 * fou1$eig[2]

res_dist <- cbind(res_dist, res_var_ax1, res_var_ax2)
con_dist <- cbind(con_dist, con_var_ax1, con_var_ax2)
# con_dist
# res_dist
```

```{r}
fou1$eig[1]
```


# Beta diversity

```{r}
library(bipartite)
```

```{r}
simu_network <- env_grad_netw(nb_resource = 50, nb_consumer = 50, nb_location = 20,
              ninter = 650,
              mean_tol_env = 0.7, mean_tol = 0.1,
              ratio_grad = 0.5, delta = 0.2)
```

```{r}
not_giant_compo <- connected_compo(simu_network, nb_frame)
simu_network <- filter_giant_component(simu_network, not_giant_compo)
tab = Reduce('+', simu_network$obs_giant_compo) # afin de générer le réseau moyen
afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
scatter(afc.tab)
```

## Visu

Les réseaux simulés ne semblent pas très réalistes. Les "abondances sont distribuées de façon trop uniforme. Et il n'y a pas d'espèce très strucutrante du milieu qui serait présente dans la majortité des frames et ferait un max d'interactions.

```{r}
plotweb(simu_network$obs_network[[1]], method="normal", text.rot=90,
        bor.col.interaction="gray40", col.high="gold2", col.low="darkgreen")

plotweb(simu_network$obs_network[[2]], method="normal", text.rot=90,
        bor.col.interaction="gray40", col.high="gold2", col.low="darkgreen")

plotweb(simu_network$obs_network[[3]], method="normal", text.rot=90,
        bor.col.interaction="gray40", col.high="gold2", col.low="darkgreen")

plotweb(simu_network$obs_network[[4]], method="normal", text.rot=90,
        bor.col.interaction="gray40", col.high="gold2", col.low="darkgreen")

plotweb(simu_network$obs_network[[5]], method="normal", text.rot=90,
        bor.col.interaction="gray40", col.high="gold2", col.low="darkgreen")
```

```{r}
array_3d <- array(unlist(simu_network$obs_network),
                  dim = c(nrow(simu_network$obs_network[[1]]),
                          ncol(simu_network$obs_network[[1]]),
                          length(simu_network$obs_network)))

dimnames(array_3d)[[1]] <- rownames(simu_network$obs_network[[1]])
dimnames(array_3d)[[2]] <- colnames(simu_network$obs_network[[1]])
dimnames(array_3d)[[3]] <- paste0("frame",1:length(simu_network$obs_network))
# array_3d
```

## Beta div

Here I first look at the beta-diversity between two frames for each possible combination of frames.

```{r}
(nw_beta_div <- betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE))

mean(nw_beta_div$OS)
mean(nw_beta_div[-1,"OS"])
mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-17,"OS"])
```

### For resources

here the goal is to remove one species at the time and then compute mean the multi beta diversity for each possible combination of frames $\Delta\beta_{OS,i} = mean(\Delta\beta_{OS,i,f_a,f_b})$.

```{r}
# Load the parallel package
library(parallel)
start_time <- Sys.time()

beta_indiv_res <- array(data = NA, 
                    dim = c(nrow(simu_network$obs_network[[1]]), 1))

rownames(beta_indiv_res) = rownames(simu_network$obs_network[[1]])
colnames(beta_indiv_res) = "delta_os"
# beta_indiv

# Define a function that simulates some computational work
my_function <- function(x) {
  mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-x, "OS"])
}

# Define a list of input values
input_values <- 1:nrow(simu_network$obs_network[[1]])

# Run the computations in parallel using mclapply
# Here, we specify the number of cores to be used with the 'mc.cores' argument
# You can adjust this number based on the number of cores available on your machine
result <- mclapply(input_values, my_function, mc.cores = 4)

# Print the results
beta_indiv_res[,1] <- unlist(result)

end_time <- Sys.time()
end_time - start_time # running time of the algorithm
hist(mean(nw_beta_div$OS) - beta_indiv_res[, 1], breaks = 10) # gives the distance to the mean contribution of the species
hist(beta_indiv_res[, 1], breaks = 10) # same but with only the contribution to rewiring for each species
```


```{r}
mean(beta_indiv_res[, 1])
mean(nw_beta_div$OS)
```


### For conumers

```{r}
start_time <- Sys.time()

beta_indiv_con <- array(data = NA, 
                    dim = c(ncol(simu_network$obs_network[[1]]), 1))

rownames(beta_indiv_con) = colnames(simu_network$obs_network[[1]])
colnames(beta_indiv_con) = "delta_os"
# beta_indiv

# Define a function that simulates some computational work
my_function <- function(x) {
  mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-x, "OS"])
}

# Define a list of input values
input_values <- 1:nrow(simu_network$obs_network[[1]])

# Run the computations in parallel using mclapply
# Here, we specify the number of cores to be used with the 'mc.cores' argument
# You can adjust this number based on the number of cores available on your machine
result <- mclapply(input_values, my_function, mc.cores = 4)

# Print the results
beta_indiv_con[,1] <- unlist(result)

end_time <- Sys.time()
end_time - start_time

br <- 8
hist(mean(nw_beta_div$OS) - beta_indiv_con[, 1], main = "distance to beta_os",breaks = br)
hist(mean(beta_indiv_con[, 1]) - beta_indiv_con[, 1], main = "distance to mean delta_beta_os", breaks = br)
hist(- beta_indiv_con[, 1], main = "contribution to beta_os (delta_beta_os)",breaks = br)
```




```{r}
sum(mean(nw_beta_div$OS) - beta_indiv_con[, 1])
mean(nw_beta_div$OS)
```


### Species level folllowing Toju et al 2024

$\beta_{WN} = \beta_{ST} + \beta_{OS} \Leftrightarrow \beta_{INT} = \beta_{ST} + \beta_{RW}$

Species contribution to rewiring

$\beta'_{RW, i} = \beta'_{RW} + \beta_{RW, \Delta i}$ and same goes for $\beta_{ST}$ and $\beta_{INT}$

I think here we would need to sum the contribution of each species foreach frames


# Compare Variance to beta diversity contribution

## Simulate the data

```{r}
simu_network <- env_grad_netw(nb_resource = 100, nb_consumer = 100, nb_location = 10,
              ninter = 40000,
              mean_tol_env = 0.7, mean_tol = 0.1,
              ratio_grad = 0.5, delta = 0.2)

############### Filter to only keep the giant component ###############
not_giant_compo <- connected_compo(simu_network, nb_frame)
simu_network <- filter_giant_component(simu_network, not_giant_compo)
tab = Reduce('+', simu_network$obs_giant_compo) # afin de générer le réseau moyen

############### AFC sur le réseau moyen ###############
afc.tab=dudi.coa(tab, nf = 6, scannf = FALSE)
scatter(afc.tab)

############### AFC su chacun des réseaux en utilisant les axes précédents ###############
fou1 = foucart(lapply(simu_network$obs_network, as.data.frame), scannf = F, nf = 2)
```

```{r}
fou1$eig[1]
```


## Variance position in the Correspondance analysis

Here, we will need to fuse the two axis because we only have one values for the beta diversity. Hence we can fuse two of them by doing the sum of the variance on the axis time the eigen-value of the corresponding axis.

```{r}
library(stringr)

############### Initiate the arrays ###############
res_var <- array(NA, c(nrow(tab), 3))
dimnames(res_var)[[1]] <- rownames(tab)
dimnames(res_var)[[2]] <- c("axis1", "axis2", "tot_res")

con_var <- array(NA, c(nrow(tab), 3))
dimnames(con_var)[[1]] <- colnames(tab)
dimnames(con_var)[[2]] <- c("axis1", "axis2", "tot_con")

############### Compute variance ###############

######## AXIS 1 ########
# for resources
res_var_ax1 <- c()
for (res in 1:nrow(tab)) {
  res1 <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var_ax1 <- c(res_var_ax1, sd(res1[, 1]))
}
hist(res_var_ax1, breaks = 20)
res_var[, 1] <- res_var_ax1

# for consumers 
con_var_ax1 <- c()
for (con in 1:ncol(tab)) {
  con1 <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var_ax1 <- c(con_var_ax1, sd(con1[, 1]))
}
hist(con_var_ax1, breaks = 20)

######## AXIS 2 ########
# for resources
res_var_ax2 <- c()
for (res in 1:nrow(tab)) {
  res1 <- fou1$Tli[str_detect(string = dimnames(fou1$Tli)[[1]],
                              pattern = paste0("^res", res, ".Ana")), ]
  res_var_ax2 <- c(res_var_ax2, sd(res1[, 2]))
}
hist(res_var_ax2, breaks = 20)

# for consumers 
con_var_ax2 <- c()
for (con in 1:ncol(tab)) {
  con1 <- fou1$Tco[str_detect(string = dimnames(fou1$Tco)[[1]],
                              pattern = paste0("^con", con, ".Ana")), ]
  con_var_ax2 <- c(con_var_ax2, sd(con1[, 2]))
}
hist(con_var_ax2, breaks = 20)

############### Tidy variance in dataframe ###############
res_var[, 1] <- res_var_ax1
con_var[, 1] <- con_var_ax1
res_var[, 2] <- res_var_ax2
con_var[, 2] <- con_var_ax2

############### Merge information from both axis ###############

res_var[ , 3] <- res_var_ax1 * fou1$eig[1] + res_var_ax2 * fou1$eig[2]
con_var[ , 3] <- con_var_ax1 * fou1$eig[1] + con_var_ax2 * fou1$eig[2]

hist(res_var[, 3], breaks = 20)
hist(con_var[, 3], breaks = 20)
```

## Beta diversity contribution

Here I first look at the beta-diversity between two frames for each possible combination of frames.

```{r}
(nw_beta_div <- betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE))

mean(nw_beta_div$OS)
mean(nw_beta_div[-1,"OS"])
mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-17,"OS"])
```

### For resources

here the goal is to remove one species at the time and then compute mean the multi beta diversity for each possible combination of frames $\Delta\beta_{OS,i} = mean(\Delta\beta_{OS,i,f_a,f_b})$.

```{r}
# Load the parallel package
library(parallel)
start_time <- Sys.time()

beta_indiv_res <- array(data = NA, 
                    dim = c(nrow(simu_network$obs_network[[1]]), 1))

rownames(beta_indiv_res) = rownames(simu_network$obs_network[[1]])
colnames(beta_indiv_res) = "delta_os"
# beta_indiv

# Define a function that simulates some computational work
my_function <- function(x) {
  mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-x, "OS"])
}

# Define a list of input values
input_values <- 1:nrow(simu_network$obs_network[[1]])

# Run the computations in parallel using mclapply
# number of cores :'mc.cores'
result <- mclapply(input_values, my_function, mc.cores = 4)

# Print the results
beta_indiv_res[,1] <- unlist(result)

end_time <- Sys.time()
end_time - start_time # running time
hist(mean(nw_beta_div$OS) - beta_indiv_res[, 1], breaks = 10) # gives the distance to the mean contribution of the species
hist(beta_indiv_res[, 1], breaks = 10) # same but with only the contribution to rewiring for each species
```


```{r}
mean(beta_indiv_res[, 1])
mean(nw_beta_div$OS)
```


### For consumers

```{r}
start_time <- Sys.time()

beta_indiv_con <- array(data = NA, 
                    dim = c(ncol(simu_network$obs_network[[1]]), 1))

rownames(beta_indiv_con) = colnames(simu_network$obs_network[[1]])
colnames(beta_indiv_con) = "delta_os"
# beta_indiv

# Define a function that simulates some computational work
my_function <- function(x) {
  mean(betalinkr_multi(array_3d, partitioning="poisot", binary=FALSE)[-x, "OS"])
}

# Define a list of input values
input_values <- 1:nrow(simu_network$obs_network[[1]])

# Run the computations in parallel using mclapply
# Here, we specify the number of cores to be used with the 'mc.cores' argument
# You can adjust this number based on the number of cores available on your machine
result <- mclapply(input_values, my_function, mc.cores = 4)

# Print the results
beta_indiv_con[,1] <- unlist(result)

end_time <- Sys.time()
end_time - start_time

br <- 8
hist(mean(nw_beta_div$OS) - beta_indiv_con[, 1], main = "distance to beta_os",breaks = br)
hist(mean(beta_indiv_con[, 1]) - beta_indiv_con[, 1], main = "distance to mean delta_beta_os", breaks = br)
hist(- beta_indiv_con[, 1], main = "contribution to beta_os (delta_beta_os)",breaks = br)
```

```{r}
sum(mean(nw_beta_div$OS) - beta_indiv_con[, 1])
mean(nw_beta_div$OS)
```


## Comparison between the variance and the beta diversity

```{r}
# beta_indiv_con
# con_var[, 3]

ggplot() +
  geom_point(data = as.data.frame(cbind(con_var, beta_indiv_con)), aes(x = tot_con, y = delta_os)) +
  xlab("variance in the correspondance analysis") +  # Add X axis label
  ylab("delta OS indiv") +  # Add Y axis label
  ggtitle("Comparison of the varinace in trhe correspondance analysis \n against the individual contribution to beta os for consumers") +  # Add plot title
  theme_bw()

ggplot() +
  geom_point(data = as.data.frame(cbind(res_var, beta_indiv_res)), aes(x = tot_res, y = delta_os)) +
  xlab("variance in the correspondance analysis") +  # Add X axis label
  ylab("delta OS indiv") +  # Add Y axis label
  ggtitle("Comparison of the varinace in trhe correspondance analysis \n against the individual contribution to beta os for resources") +  # Add plot title
  theme_bw()
```



